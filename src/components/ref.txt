 function clearAllPipingStores() {
    const confirmClear = window.confirm(
      "Are you sure you want to clear all data in the 'piping' database? This action cannot be undone."
    );

    if (!confirmClear) return; // ❌ User canceled

    const request = indexedDB.open("piping");

    request.onsuccess = function (event) {
      const db = event.target.result;
      const storeNames = Array.from(db.objectStoreNames);

      const transaction = db.transaction(storeNames, "readwrite");

      storeNames.forEach((storeName) => {
        const store = transaction.objectStore(storeName);
        store.clear().onsuccess = () => {};
        store.clear().onerror = (e) => {
          console.error(`Error clearing store ${storeName}:`, e);
        };
      });

      transaction.oncomplete = async () => {
        db.close();
        const response = await clearGlobalModal(projectId);
        if (response.status === 200) {
          alert("All data cleared from the 'piping' database.");
        } else {
          alert("Something went wrong");
        }
      };
    };

    request.onerror = function (event) {
      console.error("❌ Failed to open database:", event.target.error);
      alert("Failed to open the 'piping' database.");
    };
  }








   const loadMergedPolyMeshesWithWorkers = useCallback(async () => {
    console.log(
      "Starting to load merged low-poly models with web worker progressive LOD..."
    );
    setIsLoading(true);

    if (!sceneRef.current || !cameraRef.current) {
      setIsLoading(false);
      return;
    }

    const scene = sceneRef.current;
    const camera = cameraRef.current;

    if (camera instanceof BABYLON.UniversalCamera && camera.inputs) {
      const mouseInput = camera.inputs.attached.mouse;
      if (mouseInput && mouseInput.setLoadingState) {
        mouseInput.setLoadingState(true);
      }
    }

    // Clear scene
    console.log("Clearing existing scene content...");
    scene.meshes.slice().forEach((mesh) => {
      if (
        !mesh.name.includes("light") &&
        !mesh.name.includes("camera") &&
        !mesh.name.includes("ground") &&
        mesh.id !== "BackgroundPlane"
      ) {
        mesh.dispose();
      }
    });

    setMeshState({
      nodesAtDepth: new Array(MAX_DEPTH + 1).fill(0),
      nodeNumbersByDepth: Array.from({ length: MAX_DEPTH + 1 }, () => []),
      nodesAtDepthWithBoxes: new Array(MAX_DEPTH + 1).fill(0),
      boxesAtDepth: Array.from({ length: MAX_DEPTH + 1 }, () => new Set()),
      nodeContents: new Map(),
      nodeDepths: new Map(),
      nodeParents: new Map(),
      nodeCounter: 1,
    });

    try {
      const db = await initDB();

      const checkStoreHasData = (storeName) => {
        return new Promise((resolve, reject) => {
          const tx = db.transaction([storeName], "readonly");
          const store = tx.objectStore(storeName);
          const countRequest = store.count();
          countRequest.onsuccess = () => resolve(countRequest.result > 0);
          countRequest.onerror = () => reject(countRequest.error);
        });
      };

      const hasOctree = await checkStoreHasData("octree");
      const hasMerged = await checkStoreHasData("mergedMeshes");
      const hasOriginal = await checkStoreHasData("originalMeshes");

      if (!hasOctree || !hasMerged || !hasOriginal) {
        console.log("One or more stores are empty, fetching from backend...");
        const response = await getOctreeData(projectId);
        if (response.status === 200) {
          const { octree, mergedMeshes, originalMeshes } = response.data;
          console.log(octree, mergedMeshes, originalMeshes);

          if (octree?.OctreeId === "mainOctree" && octree.data) {
            // Save octree
            const tx = db.transaction(["octree"], "readwrite");
            const store = tx.objectStore("octree");
            await new Promise((resolve, reject) => {
              const request = store.put(octree.data, "mainOctree");
              request.onsuccess = () => resolve();
              request.onerror = () => reject(request.error);
            });
            await tx.done;
          }

          // Save merged meshes
          if (Array.isArray(mergedMeshes)) {
            const tx = db.transaction(["mergedMeshes"], "readwrite");
            const store = tx.objectStore("mergedMeshes");
            for (const mesh of mergedMeshes) {
              await new Promise((resolve, reject) => {
                const request = store.put(mesh.data, mesh.MergedMeshId);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
              });
            }
            await tx.done;
          }

          // Save original meshes
          if (Array.isArray(originalMeshes)) {
            const tx = db.transaction(["originalMeshes"], "readwrite");
            const store = tx.objectStore("originalMeshes");
            for (const mesh of originalMeshes) {
              await new Promise((resolve, reject) => {
                const value = {
                  fileName: mesh.MeshId,
                  data: mesh.data,
                };
                const request = store.put(mesh.data, mesh.MeshId);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
              });
            }
            await tx.done;
          }
        } else {
          throw new Error("Failed to fetch global model data from backend");
        }
      }

      // Load octree from IndexedDB
      const tx = db.transaction(["octree"], "readonly");
      const store = tx.objectStore("octree");
      const octreeData = await new Promise((resolve, reject) => {
        const request = store.get("mainOctree");
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });

      if (!octreeData?.bounds?.min || !octreeData.bounds?.max) {
        throw new Error("Octree bounds are missing or incomplete");
      }

      const minVector = new BABYLON.Vector3(
        octreeData.bounds.min.x,
        octreeData.bounds.min.y,
        octreeData.bounds.min.z
      );

      const maxVector = new BABYLON.Vector3(
        octreeData.bounds.max.x,
        octreeData.bounds.max.y,
        octreeData.bounds.max.z
      );

      createWireframeBox(minVector, maxVector);

      const lodManager = new WebWorkerTilesetLODManager(scene, camera, {
        currentHighlightedMeshRef,
        currentHighlightedMeshIdRef,
      });
      lodManagerRef.current = lodManager;

      const maxDistance = fitCameraToOctree(camera, maxVector, minVector);
      lodManager.setDistanceThresholds(maxDistance);

      await lodManager.initWithOctreeData(octreeData);
      await lodManager.loadAllDepth2Meshes();

      lodManager.lastCameraPosition = null;
      lodManager.frameCounter = lodManager.updateFrequency;
      lodManager.update();

      scene.onBeforeRenderObservable.add(() => {
        lodManager.update();

        const activeLOD = lodManager.getActiveLODLevel
          ? lodManager.getActiveLODLevel()
          : 0;
        const distanceToTarget =
          camera.radius ||
          BABYLON.Vector3.Distance(camera.position, camera.getTarget());
        const memUsage = lodManager.getMemoryUsage();
        lodManager.setFrustumCullingEnabled(true);
        lodManager.setDistanceCalculationEnabled(true);

        setLodInfo({
          level: activeLOD.toString(),
          distance: distanceToTarget.toFixed(0),
          memoryMB: memUsage.memoryMB,
          loadedNodes: memUsage.loadedNodes,
          cachedMeshes: memUsage.cachedMeshes,
          threshold30: lodManager.threshold30Percent?.toFixed(0) || "--",
          threshold80: lodManager.threshold80Percent?.toFixed(0) || "--",
          queuedLoads: memUsage.queuedLoads || 0,
          queuedDisposals: memUsage.queuedDisposals || 0,
          hiddenMeshes: memUsage.hiddenMeshes || 0,
          workerLoads: memUsage.workerLoads || {},
        });

        const isCurrentlyLoading =
          (memUsage.queuedLoads || 0) > 0 ||
          Object.values(memUsage.workerLoads || {}).some((load) => load > 0);

        if (isCurrentlyLoading !== isLoading) {
          setIsLoading(isCurrentlyLoading);
          if (camera instanceof BABYLON.UniversalCamera && camera.inputs) {
            const mouseInput = camera.inputs.attached.mouse;
            if (mouseInput && mouseInput.setLoadingState) {
              mouseInput.setLoadingState(isCurrentlyLoading);
            }
          }
        }
      });

      console.log(
        "Successfully loaded progressive LOD system with web workers"
      );
    } catch (error) {
      console.error("Error loading merged models with progressive LOD:", error);
    } finally {
      setIsLoading(false);
      const camera = cameraRef.current;
      if (camera instanceof BABYLON.UniversalCamera && camera.inputs) {
        const mouseInput = camera.inputs.attached.mouse;
        if (mouseInput && mouseInput.setLoadingState) {
          mouseInput.setLoadingState(false);
        }
      }
    }
  }, [initDB, createWireframeBox, fitCameraToOctree, isLoading]);
 